<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Transcription Validator</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Source+Sans+3:wght@400;500;600&display=swap');

    :root {
      --bg-primary: #1a1a2e;
      --bg-secondary: #16213e;
      --bg-tertiary: #0f3460;
      --text-primary: #eaeaea;
      --text-secondary: #a0a0a0;
      --accent: #e94560;
      --accent-hover: #ff6b6b;
      --border-color: #2a2a4a;

      /* Probability colors */
      --prob-high: #4ecdc4;    /* >= 0.9 */
      --prob-mid: #f4d03f;     /* 0.5-0.9 */
      --prob-low: #ff6b6b;     /* < 0.5 */

      /* Segment metadata badges */
      --badge-warning: #f39c12;
      --badge-alert: #e74c3c;

      /* Active states */
      --segment-active: rgba(78, 205, 196, 0.15);
      --word-active: rgba(233, 69, 96, 0.4);

      /* Glass effect borders */
      --glass-border: rgba(255, 255, 255, 0.06);
      --glass-border-hover: rgba(78, 205, 196, 0.25);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Source Sans 3', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, var(--bg-primary) 0%, #12122a 100%);
      color: var(--text-primary);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Header */
    .header {
      height: 50px;
      padding: 0 20px;
      display: flex;
      align-items: center;
      gap: 20px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
    }

    .header h1 {
      font-size: 18px;
      font-weight: 600;
    }

    .header select {
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 14px;
      cursor: pointer;
      min-width: 200px;
    }

    .header select:focus {
      outline: none;
      border-color: var(--accent);
    }

    /* Minimap */
    #minimap {
      height: 40px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      cursor: pointer;
    }

    /* Waveform */
    #waveform {
      height: 120px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      position: relative;
      overflow: hidden;
    }

    /* Controls */
    .controls {
      height: 70px;
      padding: 0 24px;
      display: flex;
      align-items: center;
      gap: 24px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
    }

    .play-btn {
      width: 50px;
      height: 50px;
      border: none;
      border-radius: 50%;
      background: var(--accent);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s, transform 0.1s;
    }

    .play-btn:hover {
      background: var(--accent-hover);
      transform: scale(1.05);
    }

    .play-btn svg {
      width: 22px;
      height: 22px;
      fill: currentColor;
    }

    .speed-buttons {
      display: flex;
      gap: 4px;
    }

    .speed-btn {
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
    }

    .speed-btn:hover {
      border-color: var(--accent);
      color: var(--text-primary);
    }

    .speed-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .header-time {
      font-family: 'JetBrains Mono', monospace;
      font-size: 22px;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(135deg, rgba(15, 52, 96, 0.95) 0%, rgba(26, 31, 58, 0.95) 100%);
      padding: 8px 16px;
      border-radius: 8px;
      border: 1px solid var(--glass-border-hover);
      letter-spacing: 1px;
    }

    /* Segments List */
    #segments {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      transition: padding-right 0.3s ease;
    }

    /* Shift segments when notes panel is open */
    body.notes-panel-open #segments {
      padding-right: 356px; /* 340px panel + 16px original padding */
    }

    .segment-card {
      background: rgba(22, 33, 62, 0.7);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      padding: 14px 16px;
      transition: all 0.2s;
      animation: fadeInUp 0.3s ease-out backwards;
    }

    .segment-card:hover {
      border-color: var(--glass-border-hover);
      background: rgba(22, 33, 62, 0.85);
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .segment-card.active {
      border-color: var(--glass-border-hover);
      background: linear-gradient(135deg, rgba(78, 205, 196, 0.12) 0%, rgba(15, 52, 96, 0.5) 100%);
      box-shadow: 0 0 20px rgba(78, 205, 196, 0.1);
    }

    .segment-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
      cursor: pointer;
    }

    .segment-header:hover {
      color: var(--accent);
    }

    .segment-id {
      font-weight: 600;
      font-size: 13px;
    }

    .segment-time {
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .segment-badges {
      display: flex;
      gap: 4px;
      margin-left: auto;
    }

    .badge {
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .badge-temp {
      background: rgba(231, 76, 60, 0.2);
      color: var(--badge-alert);
      border: 1px solid rgba(231, 76, 60, 0.3);
    }

    .badge-comp {
      background: rgba(243, 156, 18, 0.2);
      color: var(--badge-warning);
      border: 1px solid rgba(243, 156, 18, 0.3);
    }

    .badge-note {
      background: rgba(233, 69, 96, 0.2);
      color: var(--accent);
      border: 1px solid rgba(233, 69, 96, 0.3);
    }

    .segment-meta {
      font-size: 11px;
      color: var(--text-secondary);
      font-family: 'JetBrains Mono', monospace;
      margin-bottom: 8px;
    }

    .segment-words {
      line-height: 1.8;
    }

    .word {
      display: inline;
      padding: 2px 4px;
      margin: 1px;
      border-radius: 3px;
      cursor: pointer;
      transition: background 0.15s;
      position: relative;
    }

    .word:hover {
      opacity: 0.8;
    }

    .word:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      padding: 6px 10px;
      border-radius: 4px;
      white-space: nowrap;
      z-index: 100;
      pointer-events: none;
      border: 1px solid var(--border-color);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .word.active {
      background: var(--word-active) !important;
      box-shadow: 0 0 0 2px var(--accent), 0 0 12px rgba(233, 69, 96, 0.4);
    }

    .prob-high {
      background: rgba(78, 205, 196, 0.12);
      color: #5ee0d6;
    }

    .prob-mid {
      background: rgba(244, 208, 63, 0.12);
      color: #f7dc6f;
    }

    .prob-low {
      background: rgba(255, 107, 107, 0.15);
      color: #ff8a8a;
    }

    /* Note Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-overlay.visible {
      display: flex;
    }

    .modal {
      background: linear-gradient(180deg, #1a1f3a 0%, #151a2e 100%);
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      padding: 24px;
      width: 420px;
      max-width: 90%;
      box-shadow: 0 24px 48px rgba(0, 0, 0, 0.5);
    }

    .modal h3 {
      margin-bottom: 16px;
      font-size: 16px;
    }

    .modal textarea {
      width: 100%;
      height: 100px;
      padding: 12px;
      background: rgba(15, 52, 96, 0.5);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 14px;
      resize: vertical;
      margin-bottom: 16px;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .modal textarea:focus {
      outline: none;
      border-color: rgba(78, 205, 196, 0.5);
      box-shadow: 0 0 0 3px rgba(78, 205, 196, 0.1);
    }

    .modal-buttons {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .modal-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .modal-btn-cancel {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
    }

    .modal-btn-cancel:hover {
      color: var(--text-primary);
    }

    .modal-btn-save {
      background: var(--accent);
      color: white;
    }

    .modal-btn-save:hover {
      background: var(--accent-hover);
    }

    /* Context Menu */
    .context-menu {
      position: fixed;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 4px 0;
      min-width: 180px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      z-index: 1001;
      display: none;
    }

    .context-menu.visible {
      display: block;
    }

    .context-menu-item {
      padding: 8px 14px;
      cursor: pointer;
      font-size: 13px;
      transition: background 0.15s;
    }

    .context-menu-item:hover {
      background: var(--bg-tertiary);
    }

    /* Loading Overlay */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(26, 26, 46, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }

    .loading-overlay.visible {
      display: flex;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--border-color);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Keyboard Hints */
    .keyboard-hints {
      height: 32px;
      padding: 0 20px;
      display: flex;
      align-items: center;
      gap: 20px;
      background: rgba(15, 52, 96, 0.4);
      border-top: 1px solid var(--glass-border);
      font-size: 12px;
      color: var(--text-secondary);
    }

    .keyboard-hints kbd {
      padding: 3px 7px;
      background: rgba(22, 33, 62, 0.8);
      border: 1px solid var(--glass-border);
      border-radius: 4px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
    }

    /* Empty state */
    .empty-state {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-secondary);
      font-size: 16px;
    }

    /* Notes Panel */
    .notes-panel {
      position: fixed;
      top: 0;
      right: -340px;
      width: 340px;
      height: 100vh;
      background: linear-gradient(180deg, #1a1f3a 0%, #151a2e 100%);
      border-left: 2px solid rgba(78, 205, 196, 0.3);
      box-shadow: -8px 0 32px rgba(0, 0, 0, 0.4);
      z-index: 500;
      display: flex;
      flex-direction: column;
      transition: right 0.3s ease;
    }

    .notes-panel.open {
      right: 0;
    }

    .notes-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 18px 16px;
      border-bottom: 1px solid var(--glass-border);
      background: rgba(78, 205, 196, 0.05);
      gap: 10px;
    }

    #delete-all-notes {
      margin-left: auto;
    }

    .notes-panel-header h3 {
      font-size: 16px;
      font-weight: 600;
      color: var(--prob-high);
    }

    .notes-panel-close {
      width: 28px;
      height: 28px;
      border: 1px solid var(--glass-border);
      border-radius: 6px;
      background: transparent;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .notes-panel-close:hover {
      border-color: var(--prob-high);
      color: var(--prob-high);
    }

    .notes-list {
      flex: 1;
      overflow-y: auto;
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .notes-list-empty {
      color: var(--text-secondary);
      text-align: center;
      padding: 40px 20px;
      font-size: 14px;
    }

    .note-item {
      background: rgba(15, 52, 96, 0.5);
      border: 1px solid var(--glass-border);
      border-left: 3px solid var(--prob-high);
      border-radius: 8px;
      padding: 14px 16px;
      transition: all 0.2s;
    }

    .note-item:hover {
      border-color: var(--glass-border-hover);
      border-left-color: var(--prob-high);
      background: rgba(15, 52, 96, 0.65);
    }

    .note-item-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 11px;
      color: var(--text-secondary);
      font-family: 'JetBrains Mono', monospace;
    }

    .note-item-location {
      background: rgba(78, 205, 196, 0.1);
      color: var(--prob-high);
      padding: 3px 8px;
      border-radius: 4px;
    }

    .note-item-text {
      font-size: 13px;
      line-height: 1.5;
      color: var(--text-primary);
      margin-bottom: 10px;
      display: -webkit-box;
      -webkit-line-clamp: 4;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .note-item-actions {
      display: flex;
      gap: 6px;
    }

    .note-action-btn {
      padding: 5px 12px;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 11px;
      transition: all 0.2s;
    }

    .note-action-btn:hover {
      background: rgba(78, 205, 196, 0.1);
      border-color: var(--glass-border-hover);
      color: var(--text-primary);
    }

    .note-action-btn.delete:hover {
      background: rgba(231, 76, 60, 0.1);
      border-color: rgba(231, 76, 60, 0.3);
      color: #e74c3c;
    }

    .notes-toggle-btn {
      padding: 6px 14px;
      background: transparent;
      border: 1px solid var(--glass-border);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .notes-toggle-btn:hover {
      border-color: var(--glass-border-hover);
      color: var(--text-primary);
    }

    .notes-toggle-btn.active {
      background: rgba(78, 205, 196, 0.1);
      border-color: var(--glass-border-hover);
      color: var(--prob-high);
    }

    .notes-toggle-btn .note-count {
      background: linear-gradient(135deg, var(--accent) 0%, #ff6b6b 100%);
      color: white;
      padding: 2px 7px;
      border-radius: 10px;
      font-size: 11px;
      font-weight: 500;
      min-width: 20px;
      text-align: center;
    }
  </style>
</head>
<body>
  <!-- Header -->
  <div class="header">
    <h1>Transcription Validator</h1>
    <select id="session-select">
      <option value="">Select a session...</option>
    </select>
    <div class="header-time" id="time-display">00:00.0 / 00:00.0</div>
  </div>

  <!-- Minimap -->
  <div id="minimap"></div>

  <!-- Waveform -->
  <div id="waveform"></div>

  <!-- Controls -->
  <div class="controls">
    <button class="play-btn" id="play-btn">
      <svg id="play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
      <svg id="pause-icon" style="display:none" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
    </button>
    <div class="speed-buttons">
      <button class="speed-btn" data-speed="0.5">0.5x</button>
      <button class="speed-btn active" data-speed="1">1x</button>
      <button class="speed-btn" data-speed="1.5">1.5x</button>
    </div>
    <button class="notes-toggle-btn" id="notes-toggle-btn">
      Notes <span class="note-count" id="notes-count-badge">0</span>
    </button>
  </div>

  <!-- Segments List -->
  <div id="segments">
    <div class="empty-state">Select a session to begin</div>
  </div>

  <!-- Note Modal -->
  <div class="modal-overlay" id="note-modal">
    <div class="modal">
      <h3 id="note-modal-title">Add Note for Segment <span id="note-segment-id"></span></h3>
      <textarea id="note-text" placeholder="Enter your note..."></textarea>
      <div class="modal-buttons">
        <button class="modal-btn modal-btn-cancel" id="note-cancel">Cancel</button>
        <button class="modal-btn modal-btn-save" id="note-save">Save</button>
      </div>
    </div>
  </div>

  <!-- Context Menu -->
  <div class="context-menu" id="context-menu">
    <div class="context-menu-item" id="context-add-note">Add Note</div>
  </div>

  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loading">
    <div class="loading-spinner"></div>
  </div>

  <!-- Notes Panel -->
  <div class="notes-panel" id="notes-panel">
    <div class="notes-panel-header">
      <h3>Notes (<span id="notes-count">0</span>)</h3>
      <button class="note-action-btn delete" id="delete-all-notes" onclick="deleteAllNotes()">Delete All</button>
      <button class="notes-panel-close" id="notes-panel-close">&times;</button>
    </div>
    <div class="notes-list" id="notes-list">
      <div class="notes-list-empty">No notes yet</div>
    </div>
  </div>

  <!-- Keyboard Hints -->
  <div class="keyboard-hints">
    <span><kbd>Space</kbd> Play/Pause</span>
    <span><kbd>←</kbd><kbd>→</kbd> ±1s</span>
    <span><kbd>↑</kbd><kbd>↓</kbd> Prev/Next Segment</span>
    <span><kbd>N</kbd> Add Note</span>
    <span><kbd>Shift+N</kbd> Notes Panel</span>
  </div>

  <script type="module">
    import WaveSurfer from 'https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.esm.js';
    import Minimap from 'https://unpkg.com/wavesurfer.js@7/dist/plugins/minimap.esm.js';

    // State
    const state = {
      filename: null,
      segments: [],
      notes: [],
      currentTime: 0,
      currentSegmentIndex: -1,
      currentWordIndex: -1,
      playbackRate: 1,
      userScrolledAway: false,
      scrollTimeout: null,
      // Context menu state
      contextTarget: null,  // { type: 'segment'|'word', segmentIndex, wordIndex }
    };

    // DOM elements
    const sessionSelect = document.getElementById('session-select');
    const segmentsContainer = document.getElementById('segments');
    const playBtn = document.getElementById('play-btn');
    const playIcon = document.getElementById('play-icon');
    const pauseIcon = document.getElementById('pause-icon');
    const timeDisplay = document.getElementById('time-display');
    const loadingOverlay = document.getElementById('loading');
    const noteModal = document.getElementById('note-modal');
    const noteSegmentId = document.getElementById('note-segment-id');
    const noteText = document.getElementById('note-text');
    const noteSave = document.getElementById('note-save');
    const noteCancel = document.getElementById('note-cancel');
    const contextMenu = document.getElementById('context-menu');
    const contextAddNote = document.getElementById('context-add-note');
    const noteModalTitle = document.getElementById('note-modal-title');
    const notesPanel = document.getElementById('notes-panel');
    const notesPanelClose = document.getElementById('notes-panel-close');
    const notesToggleBtn = document.getElementById('notes-toggle-btn');
    const notesList = document.getElementById('notes-list');
    const notesCount = document.getElementById('notes-count');
    const notesCountBadge = document.getElementById('notes-count-badge');

    // WaveSurfer instance
    let wavesurfer = null;

    // Initialize WaveSurfer
    function initWaveSurfer() {
      if (wavesurfer) {
        wavesurfer.destroy();
      }

      wavesurfer = WaveSurfer.create({
        container: '#waveform',
        height: 120,
        waveColor: '#4ecdc4',
        progressColor: '#e94560',
        cursorColor: '#fff',
        minPxPerSec: 50,
        plugins: [
          Minimap.create({
            container: '#minimap',
            height: 40,
            waveColor: '#4ecdc4',
            progressColor: '#e94560',
          }),
        ],
      });

      wavesurfer.on('timeupdate', (time) => {
        state.currentTime = time;
        updateTimeDisplay();
        updateActiveSegment(time);
      });

      wavesurfer.on('play', () => {
        playIcon.style.display = 'none';
        pauseIcon.style.display = 'block';
      });

      wavesurfer.on('pause', () => {
        playIcon.style.display = 'block';
        pauseIcon.style.display = 'none';
      });

      wavesurfer.on('ready', () => {
        hideLoading();
        updateTimeDisplay();
      });

      wavesurfer.on('error', (error) => {
        hideLoading();
        console.error('Audio load error:', error);
        segmentsContainer.innerHTML = `<div class="empty-state">Error loading audio: ${error}</div>`;
      });

      // Add right-click handler for waveform to create timestamp notes
      document.getElementById('waveform').addEventListener('contextmenu', (e) => {
        e.preventDefault();
        if (!wavesurfer) return;
        // Calculate clicked time based on click position
        const waveformRect = document.getElementById('waveform').getBoundingClientRect();
        const clickX = e.clientX - waveformRect.left;
        const waveformWidth = waveformRect.width;
        const duration = wavesurfer.getDuration();
        const clickedTime = (clickX / waveformWidth) * duration;
        showContextMenu(e.clientX, e.clientY, { type: 'timestamp', timestamp: clickedTime });
      });

      return wavesurfer;
    }

    // Format time as seconds
    function formatTime(seconds) {
      return `${seconds.toFixed(1)}s`;
    }

    // Update time display
    function updateTimeDisplay() {
      if (!wavesurfer) return;
      const current = formatTime(state.currentTime);
      const duration = formatTime(wavesurfer.getDuration() || 0);
      timeDisplay.textContent = `${current} / ${duration}`;
    }

    // Get word probability class
    function getWordProbabilityClass(prob) {
      if (prob >= 0.9) return 'prob-high';
      if (prob >= 0.5) return 'prob-mid';
      return 'prob-low';
    }

    // Check if segment has notes
    function segmentHasNotes(segmentIndex) {
      return state.notes.some(n => n.segmentIndex === segmentIndex);
    }

    // Render segments
    function renderSegments() {
      if (state.segments.length === 0) {
        segmentsContainer.innerHTML = '<div class="empty-state">No segments found</div>';
        return;
      }

      segmentsContainer.innerHTML = state.segments.map((segment, index) => {
        const hasHighTemp = segment.temperature === 1.0;
        const hasHighComp = segment.compression_ratio > 2.5;
        const hasNotes = segmentHasNotes(index);

        const badges = [];
        if (hasHighTemp) badges.push('<span class="badge badge-temp">temp=1.0</span>');
        if (hasHighComp) badges.push('<span class="badge badge-comp">high comp</span>');
        if (hasNotes) badges.push('<span class="badge badge-note">note</span>');

        const words = (segment.words || []).map((word, wordIndex) => {
          const probClass = getWordProbabilityClass(word.probability || 0);
          const duration = ((word.end || 0) - (word.start || 0)).toFixed(3);
          const tooltip = `prob: ${(word.probability || 0).toFixed(2)} | ${word.start?.toFixed(2)}s → ${word.end?.toFixed(2)}s | dur: ${duration}s`;
          return `<span class="word ${probClass}" data-segment="${index}" data-word="${wordIndex}" data-start="${word.start}" data-tooltip="${tooltip}">${escapeHtml(word.word)}</span>`;
        }).join(' ');

        return `
          <div class="segment-card" data-segment="${index}" id="segment-${index}" style="animation-delay: ${index * 0.03}s">
            <div class="segment-header" data-start="${segment.start}">
              <span class="segment-id">Segment ${segment.id ?? index}</span>
              <span class="segment-time">${segment.start.toFixed(2)}s - ${segment.end.toFixed(2)}s</span>
              <div class="segment-badges">${badges.join('')}</div>
            </div>
            <div class="segment-meta">
              temp: ${segment.temperature ?? 'N/A'} | comp: ${(segment.compression_ratio ?? 0).toFixed(2)} | no_speech: ${(segment.no_speech_prob ?? 0).toFixed(3)}
            </div>
            <div class="segment-words">${words || '<em style="color: var(--text-secondary)">No words</em>'}</div>
          </div>
        `;
      }).join('');

      // Add click handlers
      segmentsContainer.querySelectorAll('.segment-header').forEach(header => {
        header.addEventListener('click', () => {
          const start = parseFloat(header.dataset.start);
          if (!isNaN(start)) seekAndPlay(start);
        });
      });

      segmentsContainer.querySelectorAll('.word').forEach(word => {
        word.addEventListener('click', () => {
          const start = parseFloat(word.dataset.start);
          if (!isNaN(start)) seekAndPlay(start);
        });
      });

      // Context menu handlers
      segmentsContainer.querySelectorAll('.segment-card').forEach(card => {
        card.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          const segmentIndex = parseInt(card.dataset.segment);
          showContextMenu(e.clientX, e.clientY, { type: 'segment', segmentIndex });
        });
      });

      segmentsContainer.querySelectorAll('.word').forEach(word => {
        word.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const segmentIndex = parseInt(word.dataset.segment);
          const wordIndex = parseInt(word.dataset.word);
          showContextMenu(e.clientX, e.clientY, { type: 'word', segmentIndex, wordIndex });
        });
      });
    }

    // Seek and play
    function seekAndPlay(time) {
      if (!wavesurfer) return;
      wavesurfer.setTime(time);
      wavesurfer.play();
    }

    // Update active segment and word
    function updateActiveSegment(time) {
      // Find current segment
      let newSegmentIndex = -1;
      for (let i = 0; i < state.segments.length; i++) {
        const seg = state.segments[i];
        if (time >= seg.start && time < seg.end) {
          newSegmentIndex = i;
          break;
        }
      }

      // Update segment highlight
      if (newSegmentIndex !== state.currentSegmentIndex) {
        // Remove old highlight
        if (state.currentSegmentIndex >= 0) {
          const oldCard = document.getElementById(`segment-${state.currentSegmentIndex}`);
          if (oldCard) oldCard.classList.remove('active');
        }

        // Add new highlight
        state.currentSegmentIndex = newSegmentIndex;
        if (newSegmentIndex >= 0) {
          const newCard = document.getElementById(`segment-${newSegmentIndex}`);
          if (newCard) {
            newCard.classList.add('active');

            // Auto-scroll if not manually scrolled away
            if (!state.userScrolledAway) {
              newCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }
        }
      }

      // Find and highlight current word
      document.querySelectorAll('.word.active').forEach(w => w.classList.remove('active'));

      if (newSegmentIndex >= 0) {
        const segment = state.segments[newSegmentIndex];
        const words = segment.words || [];
        for (let i = 0; i < words.length; i++) {
          const word = words[i];
          const nextWord = words[i + 1];
          const wordEnd = nextWord ? nextWord.start : segment.end;

          if (time >= word.start && time < wordEnd) {
            const wordEl = document.querySelector(`.word[data-segment="${newSegmentIndex}"][data-word="${i}"]`);
            if (wordEl) {
              wordEl.classList.add('active');
              state.currentWordIndex = i;
            }
            break;
          }
        }
      }
    }

    // Load session
    async function loadSession(stem) {
      if (!stem) {
        segmentsContainer.innerHTML = '<div class="empty-state">Select a session to begin</div>';
        return;
      }

      showLoading();
      state.filename = stem;
      state.segments = [];
      state.notes = [];
      state.currentSegmentIndex = -1;
      state.currentWordIndex = -1;

      try {
        // Load transcript
        const transcriptRes = await fetch(`/transcript/${stem}`);
        if (!transcriptRes.ok) throw new Error('Failed to load transcript');
        const transcript = await transcriptRes.json();
        state.segments = transcript.segments || [];

        // Load notes
        try {
          const notesRes = await fetch(`/notes/${stem}`);
          if (notesRes.ok) {
            const notesData = await notesRes.json();
            state.notes = notesData.notes || [];
          }
        } catch (e) {
          console.warn('Failed to load notes:', e);
          state.notes = [];
        }

        // Render segments and update notes count
        renderSegments();
        updateNotesCount();

        // Initialize and load audio
        initWaveSurfer();
        wavesurfer.load(`/audio/${stem}`);

      } catch (error) {
        console.error('Error loading session:', error);
        hideLoading();
        segmentsContainer.innerHTML = `<div class="empty-state">Error: ${error.message}</div>`;
      }
    }

    // Load available files
    async function loadFiles() {
      try {
        const res = await fetch('/files');
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();

        sessionSelect.innerHTML = '<option value="">Select a session...</option>';
        data.files.forEach(file => {
          const option = document.createElement('option');
          option.value = file;
          option.textContent = file;
          sessionSelect.appendChild(option);
        });
      } catch (error) {
        console.error('Error loading files:', error);
        sessionSelect.innerHTML = '<option value="">Error loading sessions</option>';
      }
    }

    // Show/hide loading
    function showLoading() {
      loadingOverlay.classList.add('visible');
    }

    function hideLoading() {
      loadingOverlay.classList.remove('visible');
    }

    // Note modal functions
    function openNoteModal(target = null) {
      // Pause playback when opening note modal
      if (wavesurfer && wavesurfer.isPlaying()) {
        wavesurfer.pause();
      }

      // Use passed target or fall back to current segment, or timestamp at current time
      let noteTarget = target;
      if (!noteTarget && state.currentSegmentIndex >= 0) {
        noteTarget = { type: 'segment', segmentIndex: state.currentSegmentIndex };
      } else if (!noteTarget && wavesurfer) {
        // No segment active, create timestamp note at current playback position
        noteTarget = { type: 'timestamp', timestamp: state.currentTime };
      }

      if (!noteTarget) return;

      state.contextTarget = noteTarget;

      // Update modal title
      if (noteTarget.type === 'timestamp') {
        noteModalTitle.innerHTML = `Add Note at <strong>${noteTarget.timestamp.toFixed(1)}s</strong>`;
      } else if (noteTarget.type === 'word') {
        const word = state.segments[noteTarget.segmentIndex]?.words?.[noteTarget.wordIndex];
        const time = word?.start?.toFixed(2) || '0.00';
        noteModalTitle.innerHTML = `Add Note for Word "<em>${escapeHtml(word?.word || '')}</em>" at ${time}s`;
      } else {
        const segmentId = state.segments[noteTarget.segmentIndex]?.id ?? noteTarget.segmentIndex;
        noteModalTitle.innerHTML = `Add Note for Segment <span id="note-segment-id">${segmentId}</span>`;
      }

      noteText.value = '';

      // Check for existing note
      let existingNote;
      if (noteTarget.type === 'timestamp') {
        // Match timestamp notes within 0.5s tolerance
        existingNote = state.notes.find(n =>
          n.segmentIndex == null && Math.abs(n.timestamp - noteTarget.timestamp) < 0.5
        );
      } else {
        existingNote = state.notes.find(n =>
          n.segmentIndex === noteTarget.segmentIndex &&
          (noteTarget.type === 'word' ? n.wordIndex === noteTarget.wordIndex : n.wordIndex == null)
        );
      }
      if (existingNote) {
        noteText.value = existingNote.text;
      }

      noteModal.classList.add('visible');
      noteText.focus();
    }

    function closeNoteModal() {
      noteModal.classList.remove('visible');
    }

    async function saveNote() {
      const text = noteText.value.trim();
      const target = state.contextTarget;

      if (!text || !target) {
        closeNoteModal();
        return;
      }

      // Remove existing note for this target
      state.notes = state.notes.filter(n => {
        if (target.type === 'timestamp') {
          // Match timestamp notes within 0.5s tolerance
          return !(n.segmentIndex == null && Math.abs(n.timestamp - target.timestamp) < 0.5);
        }
        if (target.type === 'word') {
          return !(n.segmentIndex === target.segmentIndex && n.wordIndex === target.wordIndex);
        }
        return !(n.segmentIndex === target.segmentIndex && n.wordIndex == null);
      });

      // Add new note
      const note = {
        id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        segmentIndex: target.type === 'timestamp' ? null : target.segmentIndex,
        wordIndex: target.type === 'word' ? target.wordIndex : null,
        timestamp: target.type === 'timestamp' ? target.timestamp : state.currentTime,
        text: text,
        createdAt: new Date().toISOString(),
      };
      state.notes.push(note);

      // Save to server
      try {
        const res = await fetch(`/notes/${state.filename}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ notes: state.notes }),
        });
        if (!res.ok) throw new Error(`Save failed: ${res.status}`);
      } catch (error) {
        console.error('Error saving note:', error);
        alert('Failed to save note. Please try again.');
        return;
      }

      closeNoteModal();
      renderSegments();
      updateActiveSegment(state.currentTime);

      // Update notes panel if open
      if (notesPanel.classList.contains('open')) {
        renderNotesList();
      } else {
        updateNotesCount();
      }
    }

    // Context menu functions
    function showContextMenu(x, y, target) {
      state.contextTarget = target;

      // Update menu item text
      if (target.type === 'timestamp') {
        contextAddNote.textContent = `Add Note at ${target.timestamp.toFixed(1)}s`;
      } else if (target.type === 'word') {
        const word = state.segments[target.segmentIndex]?.words?.[target.wordIndex];
        contextAddNote.textContent = `Add Note for "${word?.word || 'word'}"`;
      } else {
        const segmentId = state.segments[target.segmentIndex]?.id ?? target.segmentIndex;
        contextAddNote.textContent = `Add/Edit Note for Segment ${segmentId}`;
      }

      // Position menu
      contextMenu.style.left = `${x}px`;
      contextMenu.style.top = `${y}px`;
      contextMenu.classList.add('visible');

      // Adjust if menu goes off screen
      const rect = contextMenu.getBoundingClientRect();
      if (rect.right > window.innerWidth) {
        contextMenu.style.left = `${window.innerWidth - rect.width - 10}px`;
      }
      if (rect.bottom > window.innerHeight) {
        contextMenu.style.top = `${window.innerHeight - rect.height - 10}px`;
      }
    }

    function hideContextMenu() {
      contextMenu.classList.remove('visible');
    }

    // Notes panel functions
    function toggleNotesPanel() {
      notesPanel.classList.toggle('open');
      const isOpen = notesPanel.classList.contains('open');
      notesToggleBtn.classList.toggle('active', isOpen);
      document.body.classList.toggle('notes-panel-open', isOpen);
      if (isOpen) {
        renderNotesList();
      }
    }

    function closeNotesPanel() {
      notesPanel.classList.remove('open');
      notesToggleBtn.classList.remove('active');
      document.body.classList.remove('notes-panel-open');
    }

    function updateNotesCount() {
      const count = state.notes.length;
      notesCount.textContent = count;
      notesCountBadge.textContent = count;
    }

    function renderNotesList() {
      updateNotesCount();

      if (state.notes.length === 0) {
        notesList.innerHTML = '<div class="notes-list-empty">No notes yet</div>';
        return;
      }

      // Sort notes by timestamp for timestamp notes, then segment index, then word index
      const sortedNotes = [...state.notes].sort((a, b) => {
        // Timestamp-only notes sorted by their timestamp
        const aIsTimestamp = a.segmentIndex == null;
        const bIsTimestamp = b.segmentIndex == null;

        // Get effective time for sorting
        const aTime = aIsTimestamp ? a.timestamp : (state.segments[a.segmentIndex]?.start || 0);
        const bTime = bIsTimestamp ? b.timestamp : (state.segments[b.segmentIndex]?.start || 0);

        // Primary sort by time
        if (Math.abs(aTime - bTime) > 0.01) {
          return aTime - bTime;
        }

        // If same time, timestamp notes come after segment notes
        if (aIsTimestamp !== bIsTimestamp) {
          return aIsTimestamp ? 1 : -1;
        }

        // For segment notes, sort by word index
        if (!aIsTimestamp && !bIsTimestamp) {
          // Segment notes (wordIndex null) come before word notes
          if (a.wordIndex == null && b.wordIndex != null) return -1;
          if (a.wordIndex != null && b.wordIndex == null) return 1;
          return (a.wordIndex || 0) - (b.wordIndex || 0);
        }

        return 0;
      });

      notesList.innerHTML = sortedNotes.map(note => {
        const segment = note.segmentIndex != null ? state.segments[note.segmentIndex] : null;
        let location, time;

        if (note.segmentIndex == null) {
          // Timestamp-only note (no segment association)
          location = `@ ${formatTime(note.timestamp)}`;
          time = formatTime(note.timestamp);
        } else if (note.wordIndex != null) {
          const word = segment?.words?.[note.wordIndex];
          const segmentId = segment?.id ?? note.segmentIndex;
          location = `Seg ${segmentId} | Word "${escapeHtml(word?.word || '?')}"`;
          time = formatTime(word?.start || 0);
        } else {
          location = `Segment ${segment?.id ?? note.segmentIndex}`;
          time = formatTime(segment?.start || 0);
        }

        const textPreview = note.text.length > 100 ? note.text.substring(0, 100) + '...' : note.text;

        return `
          <div class="note-item" data-note-id="${note.id}">
            <div class="note-item-header">
              <span class="note-item-location">${location}</span>
              <span>${time}</span>
            </div>
            <div class="note-item-text">${escapeHtml(textPreview)}</div>
            <div class="note-item-actions">
              <button class="note-action-btn" onclick="jumpToNote('${note.id}')">Jump</button>
              <button class="note-action-btn" onclick="editNoteFromPanel('${note.id}')">Edit</button>
              <button class="note-action-btn delete" onclick="deleteNote('${note.id}')">Delete</button>
            </div>
          </div>
        `;
      }).join('');
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Make functions globally accessible for onclick handlers
    window.jumpToNote = function(noteId) {
      const note = state.notes.find(n => n.id === noteId);
      if (!note) return;

      let seekTime;

      if (note.segmentIndex == null) {
        // Timestamp-only note - seek directly to timestamp
        seekTime = note.timestamp;
      } else {
        const segment = state.segments[note.segmentIndex];
        if (!segment) return;

        if (note.wordIndex != null) {
          const word = segment.words?.[note.wordIndex];
          seekTime = word?.start ?? segment.start;
        } else {
          seekTime = segment.start;
        }

        // Scroll to segment
        const segmentCard = document.getElementById(`segment-${note.segmentIndex}`);
        if (segmentCard) {
          segmentCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }

      // Seek audio
      if (wavesurfer) {
        wavesurfer.setTime(seekTime);
      }

      // Close notes panel on mobile for better UX
      if (window.innerWidth < 768) {
        closeNotesPanel();
      }
    };

    window.editNoteFromPanel = function(noteId) {
      const note = state.notes.find(n => n.id === noteId);
      if (!note) return;

      let target;
      if (note.segmentIndex == null) {
        // Timestamp-only note
        target = { type: 'timestamp', timestamp: note.timestamp };
      } else {
        target = {
          type: note.wordIndex != null ? 'word' : 'segment',
          segmentIndex: note.segmentIndex,
          wordIndex: note.wordIndex
        };
      }

      openNoteModal(target);
    };

    window.deleteNote = async function(noteId) {
      if (!confirm('Delete this note?')) return;

      state.notes = state.notes.filter(n => n.id !== noteId);

      // Save to server
      try {
        const res = await fetch(`/notes/${state.filename}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ notes: state.notes }),
        });
        if (!res.ok) throw new Error(`Save failed: ${res.status}`);
      } catch (error) {
        console.error('Error deleting note:', error);
        alert('Failed to delete note. Please try again.');
        return;
      }

      renderNotesList();
      renderSegments();
      updateActiveSegment(state.currentTime);
    };

    window.deleteAllNotes = async function() {
      if (state.notes.length === 0) return;

      if (!confirm(`Delete all ${state.notes.length} notes? This cannot be undone.`)) return;

      state.notes = [];

      try {
        const res = await fetch(`/notes/${state.filename}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ notes: state.notes }),
        });
        if (!res.ok) throw new Error(`Save failed: ${res.status}`);
      } catch (error) {
        console.error('Error deleting all notes:', error);
        alert('Failed to delete notes. Please try again.');
        return;
      }

      renderNotesList();
      renderSegments();
      updateActiveSegment(state.currentTime);
    };

    // Keyboard shortcuts
    function handleKeyboard(e) {
      // Don't handle if modal is open and typing
      if (noteModal.classList.contains('visible')) {
        if (e.key === 'Escape') {
          closeNoteModal();
          e.preventDefault();
        }
        return;
      }

      switch (e.key) {
        case ' ':
          e.preventDefault();
          if (wavesurfer) {
            wavesurfer.playPause();
          }
          break;

        case 'ArrowLeft':
          e.preventDefault();
          if (wavesurfer) {
            wavesurfer.setTime(Math.max(0, state.currentTime - 1));
          }
          break;

        case 'ArrowRight':
          e.preventDefault();
          if (wavesurfer) {
            wavesurfer.setTime(Math.min(wavesurfer.getDuration(), state.currentTime + 1));
          }
          break;

        case 'ArrowUp':
          e.preventDefault();
          if (state.currentSegmentIndex > 0) {
            const prevSegment = state.segments[state.currentSegmentIndex - 1];
            seekAndPlay(prevSegment.start);
          }
          break;

        case 'ArrowDown':
          e.preventDefault();
          if (state.currentSegmentIndex < state.segments.length - 1) {
            const nextSegment = state.segments[state.currentSegmentIndex + 1];
            seekAndPlay(nextSegment.start);
          }
          break;

        case 'n':
          e.preventDefault();
          openNoteModal();
          break;

        case 'N':
          e.preventDefault();
          toggleNotesPanel();
          break;
      }
    }

    // Event listeners
    sessionSelect.addEventListener('change', (e) => {
      loadSession(e.target.value);
    });

    playBtn.addEventListener('click', () => {
      if (wavesurfer) {
        wavesurfer.playPause();
      }
    });

    document.querySelectorAll('.speed-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const speed = parseFloat(btn.dataset.speed);
        state.playbackRate = speed;

        if (wavesurfer) {
          wavesurfer.setPlaybackRate(speed);
        }

        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      });
    });

    noteSave.addEventListener('click', saveNote);
    noteCancel.addEventListener('click', closeNoteModal);

    notesToggleBtn.addEventListener('click', toggleNotesPanel);
    notesPanelClose.addEventListener('click', closeNotesPanel);

    document.addEventListener('keydown', handleKeyboard);

    // Context menu event listeners
    contextAddNote.addEventListener('click', () => {
      openNoteModal(state.contextTarget);
      hideContextMenu();
    });

    // Hide context menu on click outside
    document.addEventListener('click', () => {
      hideContextMenu();
    });

    // Scroll detection (single listener, not per-render)
    segmentsContainer.addEventListener('scroll', () => {
      hideContextMenu();
      state.userScrolledAway = true;
      clearTimeout(state.scrollTimeout);
      state.scrollTimeout = setTimeout(() => {
        state.userScrolledAway = false;
      }, 5000);
    }, { passive: true });

    // Initialize
    loadFiles();
  </script>
</body>
</html>
